[ 상속 ]
	1. 부모로부터 자식이나 손자까지 물려주는 행위
	2. 부모클래스/상위클래스 , 자식클래스/하위클래스 
	3. extends	키워드 , '연장,확장 하다'
			class 하위클래스 extends 상위클래스{ }
	4. 예]
			포유류( 고래 , 원숭이 등등 )	<---- 일반적인 개념 
			|
			v
			사람						<---- 구체적인 개념 
	5. 목적 : 특정 클래스의 멤버변수 나 메소드를 물려받아 또 다른 클래스를 빠른 설계
	6. 장점 : 1. 유지보수 2.계층구조파악 3. 재사용성 4. *다형성*
	7. 하위클래스가 상위클래스의 멤버변수,메소드를 사용할수 있다.
		---> 단] 현실세계와 다르게 하위클래스가 상위클래스를 선택한다. ( 자식이 부모를 선택한다. )
		
	8. 타입변환 ? 분류를 변환하는 행위
		0. 타입이란 ? 자료 속성의 분류 , 클래스 
		1. 자동(묵시적)타입변환 : 
			[ 기본타입 ]
			- 작은타입에서 큰타입으로 기본타입이 변환 , 큰타입이 메모리적으로 더 크니까 , 데이터의 표현 범위가 더 크다
			- byte -> short -> int -> long -> float -> double
			[ 참조타입 ]
			- 하위클래스(타입) 에서 상위클래스(타입)으로 변환 
			- *자바의 모든 클래스는 Object 클래스로 타입변환이 가능하다. ( 상-하 관계에서 가능하다 )
		
		2. 강제(명시적)타입변환 , 캐스팅 : ()
			[ 기본타입 ]
			- 큰타입에서 작은타입으로 기본타입이 변환 , 작은타입이 메모리적으로 더 작으니까 손실 , 데이터의 표현 범위가 더 작다
			- double -> float -> long -> int -> short -> byte 
			[ 참조타입 ]
			- 상위클래스(타입) 에서 하위클래스(타입)으로 변환이 불가능하다. 가능한 전제조건이 있다. 
			- 가능한 전제조건 : 인스턴스(객체)가 본래 변환할 타입으로 생성된 경우에는 가능하다. ( 상-하 관계에서 가능하다 )
		
	[ 물리적인 설계 ]
	9. **** 하위클래스가 객체(인스턴스) 생성하면 상위클래스의 객체(인스턴스)도 같이 메모리 할당 ****
		즉] 하위클래스는 부모클래스 없이 인스턴스를 생성할수 없다.
	[ 논리적인 설계 ]
	10. Object 클래스 이란? 자바의 모든 클래스 중에 가장 최상위 (슈퍼)클래스
		- 자바회사에서 내부적으로 모든 클래스는 Object 클래스로 부터 상속 받도록 설계
		즉] 내가 만든 클래스와 자바의 모든 클래스는 Object 클래스로부터 상속받는다. 자바는 100% 상속
		
			Object 클래스 
			ㅣ
			v
			포유류 클래스 ( 고래 , 원숭이 등등 )	<---- 일반적인 개념 
			|
			v
			사람	클래스 						<---- 구체적인 개념 
	
	11. 타입 확인 
		변수명 instanceof 타입
	
	12. super 
		1. 생성자/메소드 { } 안에서 사용되는 키워드
		2. super.멤버변수 : 
			- 메소드를 호출한 인스턴스의 상위 클래스 멤버변수 가리킨다.
		3. super( ) :
			- 생성자를 호출한 인스턴스의 상위 클래스의 생성자를 가리킨다. 
			- 디폴트 생성자는 생략이 가능하다.
		
	*this란 : 생성자/메소드 { } 안에서 사용.
		-> 현재 생성자/메소드를 호출한 인스턴스 가리키는 키워드
	 	1. this.멤버변수 : 
	 		- 메소드를 호출한 인스턴스의 멤버변수를 가리킨다.
	 	2. this( ) :
	 		- 생성자를 호출한 인스턴스의 생성자를 가리킨다.
	 		
	13. 오버라이딩 과 오버로딩 
		- 원래 코드는 메소드/생성자 명을 동일하게 정의할 수 없다. ( 메소드명/생성자명 중복 불가능 ) 
		- 오버라이딩/오버로딩 : 동일한 메소드명으로 여러개 메소드를 정의할 수 있도록 지원하는 문법 
		
	* 오버라이딩
		- 상속관계에 있어서 상위 클래스의 메소드명과 동일하게 선언이 가능하다.
		- 전제조건 : 반환타입 메소드명 매개변수 가 모두 동일하게 작성해야 한다. 
		- 목적 : 상위 클래스의 메소드를 재정의 하기 위해 
		- 주로 사용처 : 상속 extends
		
		class A{ void method(){} }
		class B extends A { void method(){} }
		
	* 오버로딩
		- 동일한 메소드/생상자 명 으로 여러개 선언이 가능하다.
		- 전제조건 : 매개변수의 개수, 매개변수 순서, 매개변수 타입 중에서 한개라도 차이점이 존재하면 동일한 메소드명으로 선언이 가능하다.
		- 목적 : 다양한 상황에 따라 초기값을 제공하기 위해  
		- 주로 사용처 : 생성자 , 메소드
		member( int a ){ }
		member( int a , int b ) { }
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	